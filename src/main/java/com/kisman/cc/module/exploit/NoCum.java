package com.kisman.cc.module.exploit;

import com.kisman.cc.Kisman;
import com.kisman.cc.event.events.PacketEvent;
import com.kisman.cc.event.events.client.settings.EventSettingChange;
import com.kisman.cc.module.*;
import com.kisman.cc.settings.Setting;
import i.gishreloaded.gishcode.utils.visual.ChatUtils;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.server.SPacketBlockChange;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.text.TextFormatting;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent;
import org.lwjgl.opengl.Display;

import java.text.DecimalFormat;
import java.util.ArrayList;

public class NoCum extends Module {
    private Setting noCum = new Setting("No Cum", this, false);
    private Setting ignore = new Setting("Ignore", this, true);
    private Setting latency = new Setting("Latency", this, false);
    private Setting ignoreLoaded = new Setting("Ignore Loaded", this, true);
    private Setting loadChunks = new Setting("Load Chunks", this, false);
    private Setting notify = new Setting("Notify", this, false);

    private Setting noCumAround = new Setting("No Cum Around", this, false);

    private Setting noCumHighway = new Setting("No Cum Highway", this, false);

    private Setting noCumMTracker = new Setting("No Cum M Tracker", this, false);

    private Setting noCumScanner = new Setting("No Cum Scanner", this, false);

    private Setting noCumSpiral = new Setting("No Cum Spiral", this, false);
    private final Setting noCumSpiralMode = new Setting("No Cum Spiral Mode", this, NoCumSpiralModes.ZERO_ZERO);
    private final Setting noCumSpiralCenterX = new Setting("No Cum Spiral Center X", this, 1, 0, 2, true).setVisible(() -> noCumSpiralMode.checkValString("CUSTOM"));
    private final Setting noCumSpiralCenterZ = new Setting("No Cum Spiral Center Z", this, 1, 0, 2, true).setVisible(() -> noCumSpiralMode.checkValString("CUSTOM"));
    private final Setting noCumSpiralMax = new Setting("No Cum Spiral Max", this, 1, 0, 2, true);
    private final Setting noCumSpiralSkip = new Setting("No Cum Spiral Skip", this, 1, 0, 2, true);
    private final Setting noCumSpiralStep = new Setting("No Cum Spiral Step", this, 1, 144, 145, true);
    private final Setting noCumSpiralPPT = new Setting("No Cum Spiral PPT", this, 4, 1, 15, true);
    private final Setting noCumSpiralDebug = new Setting("No Cum Spiral Debug", this, false);

    private Setting noCumTracker = new Setting("No Cum Tracker", this, false);

    //NoCum vars
    private ArrayList<ChunkPos> loadedChunks = new ArrayList<>();
    private final int MAX_DL_PTT = 15;
    private long startTime;
    public int x, y, z;

    //NoCum Spiral vars
    public int spiralX, spiralZ, sx, sz, center_x, center_z, centreX, centreY, max, steps;
    private boolean isSkipping = false;

    //instance
    public static NoCum instance;

    public NoCum() {
        super("NoCum", Category.EXPLOIT);

        instance = this;

        setmgr.rSetting(new Setting("cam1", this, "No Cum"));
        setmgr.rSetting(noCum);
        setmgr.rSetting(latency);
        setmgr.rSetting(ignoreLoaded);
        setmgr.rSetting(loadChunks);
        setmgr.rSetting(notify);

        setmgr.rSetting(new Setting("c3am1", this, "No Cum Around"));
        setmgr.rSetting(noCumAround);

        setmgr.rSetting(new Setting("cam41", this, "No Cum Highway"));
        setmgr.rSetting(noCumHighway);

        setmgr.rSetting(new Setting("c6am1", this, "No Cum M Tracker"));
        setmgr.rSetting(noCumMTracker);

        setmgr.rSetting(new Setting("cgam1", this, "No Cum Scanner"));
        setmgr.rSetting(noCumScanner);

        setmgr.rSetting(new Setting("camn1", this, "No Cum Spiral"));
        setmgr.rSetting(noCumSpiral);
        setmgr.rSetting(noCumSpiralMode);
        setmgr.rSetting(noCumSpiralCenterX);
        setmgr.rSetting(noCumSpiralCenterZ);
        setmgr.rSetting(noCumSpiralMax);
        setmgr.rSetting(noCumSpiralSkip);
        setmgr.rSetting(noCumSpiralStep);
        setmgr.rSetting(noCumSpiralPPT);
        setmgr.rSetting(noCumSpiralDebug);

        setmgr.rSetting(new Setting("cahm1", this, "No Cum Tracker"));
        setmgr.rSetting(noCumTracker);
    }

    public void onEnable() {
        Kisman.EVENT_BUS.subscribe(receive);
        Kisman.EVENT_BUS.subscribe(settingListener);
        if (mc.world == null) return;
        final BlockPos pos = new BlockPos(x, y, z);
        this.startTime = System.currentTimeMillis();
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, EnumFacing.UP));
    }

    public void onDisable() {
        Kisman.EVENT_BUS.unsubscribe(settingListener);
        Kisman.EVENT_BUS.unsubscribe(receive);
        startTime = -1;
        unloadChunks();
    }

    public void update() {
        if(mc.player == null || mc.world == null) return;
        if(noCumSpiral.getValBoolean()) updateNoCumSpiral();
    }

    @EventHandler
    private final Listener<EventSettingChange.BooleanSetting> settingListener = new Listener<>(event -> {
        if(event.setting.equals(noCumSpiral)) {
            if(event.setting.getValBoolean()) onEnableNoCumSpiral();
            else onDisableNoCumSpiral();
        }
    });

    private void onEnableNoCumSpiral() {
        if(mc.player == null || mc.world == null) return;
        spiralX = spiralZ = noCumSpiralSkip.getValInt();

        switch(noCumSpiralMode.getValString()) {
            case "ZERO_ZERO":
                center_x = center_z = 0;
                break;
            case "YOU":
                center_x = (int) mc.player.posX;
                center_z = (int) mc.player.posZ;
                break;
            case "CUSTOM":
                center_x = noCumSpiralCenterX.getValInt();
                center_z = noCumSpiralCenterZ.getValInt();
                break;
        }

        steps = noCumSpiralStep.getValInt();
        isSkipping = noCumSpiralSkip.getValInt() != 0;
    }

    private void onDisableNoCumSpiral() {
        if(mc.player == null || mc.world == null) return;
        ChatUtils.complete("[NoCumSpiral] Stopped at " + sx + ", " + sz);
    }

    private void updateNoCumSpiral() {
        if(mc.player.connection == null) return;
        for(int i = 0; y < noCumSpiralPPT.getValInt(); ++i) {
            sx = spiralX + center_x;
            sz = spiralZ + center_z;
            if(noCumSpiralDebug.getValBoolean()) ChatUtils.warning("[NoCumSpiral] " + sx + ", " + sz);
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, new BlockPos(sx, 0, sz), EnumFacing.UP));
            if(isSkipping) {
                if(Math.abs(spiralX) < Math.abs(spiralZ) && (spiralX != spiralZ || spiralX >= 0)) spiralX += spiralZ >= 0 ? steps : -steps;
                else spiralZ += spiralX >= 0 ? -steps : steps;
            } else if(Math.abs(spiralX) <= Math.abs(spiralZ) && (spiralX != spiralZ || spiralX > 0)) spiralX += spiralZ >= 0 ? steps : -steps;
            else spiralZ += spiralX >= 0 ? -steps : steps;
            if(noCumSpiralMax.getValInt() > steps && spiralX > noCumSpiralMax.getValInt()) {
                spiralX = spiralZ = 0;
                ChatUtils.complete("[NoCumSpiral] Maximum reached, Resetting spiral relative coords and scanning again.");
            }
        }
    }

    @SubscribeEvent
    public void onConnect(FMLNetworkEvent.ClientConnectedToServerEvent event) {
        unloadChunks();
    }

    @EventHandler
    private final Listener<PacketEvent.Receive> receive = new Listener<>(event -> {
        if(noCum.getValBoolean()) {
            if(event.getPacket() instanceof SPacketBlockChange) {
                SPacketBlockChange packet = (SPacketBlockChange) event.getPacket();
                ChunkPos chunkPos = new ChunkPos(packet.getBlockPosition());
                if (this.ignore.getValBoolean()) {
                    if (!this.loadedChunks.contains(chunkPos) && mc.world.isBlockLoaded(packet.getBlockPosition(), false)) return;
                    if (this.notify.getValBoolean() && !Display.isActive()) ChatUtils.message("DL found something.");
                }
                final DecimalFormat df = new DecimalFormat("#.#");
                final Vec3d pos1 = new Vec3d(mc.player.getPosition().getX(), packet.getBlockPosition().getY(), mc.player.getPosition().getZ());
                ChatUtils.message("&7[&aM&7] &r" + TextFormatting.RED + "[DL]: " + TextFormatting.RESET + packet.getBlockPosition() + " -> " + packet.getBlockState().getBlock().getLocalizedName() + " (" + df.format(pos1.distanceTo(new Vec3d(packet.getBlockPosition()))) + ") " + ((mc.player.dimension == -1) ? "Nether" : ""));
                if (latency.getValBoolean() && startTime != -1L) {
                    ChatUtils.message("Latency = " + (System.currentTimeMillis() - this.startTime) + " ms");
                    startTime = -1L;
                }
                if (loadChunks.getValBoolean() && loadChunks.isVisible() && !this.loadedChunks.contains(chunkPos)) {
                    mc.world.doPreChunk(chunkPos.x, chunkPos.z, true);
                    this.loadedChunks.add(chunkPos);
                }
            }
        }
    });

    private void unloadChunks() {
        if (mc.world != null) for (ChunkPos chunkPos : loadedChunks) mc.world.doPreChunk(chunkPos.x, chunkPos.z, false);
        loadedChunks.clear();
    }

    public enum NoCumSpiralModes {ZERO_ZERO, YOU, CUSTOM}
}
