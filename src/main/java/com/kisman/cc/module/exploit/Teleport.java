package com.kisman.cc.module.exploit;

import com.kisman.cc.module.*;
import com.kisman.cc.gui.csgo.components.Slider;
import com.kisman.cc.settings.Setting;
import com.kisman.cc.util.EntityUtil;
import i.gishreloaded.gishcode.utils.visual.ChatUtils;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.network.play.client.CPacketPlayer;
import org.lwjgl.input.Keyboard;

/**
 * -Invented by TuxISCool
 * -Worked out by zPrestige_
 */
public class Teleport extends Module {
    private Setting force = new Setting("Force", this, 1, 0.1f, 10, false);
    private Setting attempts = new Setting("Attempts", this, 10, 1, 20, true);
    private Setting distance = new Setting("Distance", this, 5, 1, 50, true);
    private Setting enemyTpKey = new Setting("Enemy Tp Key", this, Keyboard.KEY_NONE);
    private Setting oneBlockKey = new Setting("One BlockKey", this, Keyboard.KEY_NONE);
    private Setting hold = new Setting("Hold", this, false);
    private Setting airGlide = new Setting("Air Glide", this, false);
    private Setting verticalGlideSpeed = new Setting("Vertical Glide Speed", this, 1, 0.1f, 100, Slider.NumberType.PERCENT);

    private boolean executed;

    public Teleport() {
        super("Teleport", "5b5t teleport exploit by zPrestige_", Category.EXPLOIT);

        setmgr.rSetting(force);
        setmgr.rSetting(attempts);
        setmgr.rSetting(distance);
        setmgr.rSetting(enemyTpKey);
        setmgr.rSetting(oneBlockKey);
        setmgr.rSetting(hold);
        setmgr.rSetting(airGlide);
        setmgr.rSetting(verticalGlideSpeed);
    }

    public void update() {
        if(mc.player == null || mc.world == null) return;

        if(enemyTpKey.getKey() != Keyboard.KEY_NONE) {
            if(Keyboard.isKeyDown(enemyTpKey.getKey())) {
                EntityPlayer target = EntityUtil.getTarget(200f);
                if(target == null) ChatUtils.error("No target found unable to teleport((");
                else {
                    for (int i = 0; i < attempts.getValInt(); ++i) {
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValFloat() / 10), mc.player.posZ, false));
                        mc.player.connection.sendPacket(new CPacketPlayer.Position(target.posX, target.posY, target.posZ, true));
                    }
                }
                return;
            }
        }

        if(airGlide.getValBoolean()) {
            mc.player.motionY = -0.01;
            double currY = mc.player.posY;
            if(mc.gameSettings.keyBindJump.isKeyDown()) for(int i = 0; i < attempts.getValInt(); ++i) mc.player.setPosition(mc.player.posX, currY + verticalGlideSpeed.getValFloat() / 100f, mc.player.posZ);
            if(mc.gameSettings.keyBindSneak.isKeyDown()) for(int i = 0; i < attempts.getValInt(); ++i) mc.player.setPosition(mc.player.posX, currY - verticalGlideSpeed.getValFloat() / 100f, mc.player.posZ);
        }

        if(oneBlockKey.getKey() != Keyboard.KEY_NONE) {
            if(Keyboard.isKeyDown(oneBlockKey.getKey())) {
                for(int i = 0; i < attempts.getValInt(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValFloat() / 10), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -1);
                            break;
                        case EAST:
                            sendPacket(1, 0, 0);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, 1);
                            break;
                        case WEST:
                            sendPacket(-1, 0, 0);
                            break;
                    }
                }
            }
        }

        if(mc.gameSettings.keyBindAttack.isKeyDown()) {
            if(!executed || hold.getValBoolean()) {
                for(int i = 0; i < attempts.getValInt(); ++i) {
                    mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (force.getValFloat() / 10), mc.player.posZ, false));
                    switch (mc.player.getHorizontalFacing()) {
                        case NORTH:
                            sendPacket(0, 0, -distance.getValInt());
                            break;
                        case EAST:
                            sendPacket(distance.getValInt(), 0, 0);
                            break;
                        case SOUTH:
                            sendPacket(0, 0, distance.getValInt());
                            break;
                        case WEST:
                            sendPacket(-distance.getValInt(), 0, 0);
                            break;
                    }
                    executed = true;
                }
            }
        } else executed = false;
    }

    private void sendPacket(double x, double y, double z) {
        mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + x, mc.player.posY + y, mc.player.posZ + z, true));
    }
}
